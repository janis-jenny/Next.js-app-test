import { Fragment } from 'react';
import Head from 'next/head';
import { MongoClient } from 'mongodb'; // if is used in getStaticProps will no executed in client side bundle, for bundle size & security
import MeetupList from '../components/meetups/MeetupList';

// No recommended to use useState and useEffect because of 1st render cycles we have a proble with SEO and may be missing some data,
// the prerender html page doesnt wait the 2nd cycle generated by using useEffect, it always takes the result of the first render cycle 
// and returns that as the prerender html page content, we need to tell next when we are done waiting of the fetch data
export default function Home(props) {
  return (
    <Fragment>
      <Head>
        <title>React Meetups</title>
        <meta 
          name='description'
          content='Browse a list of meet ups!'/>
      </Head>
      <MeetupList meetups={props.meetups} />  
    </Fragment>
  )
}
// if we wanna pre render a page with data, next offers 1 ways of prerendering for controlling how the page should be render:
// static generationa and server side rendering
// static generation: page component is pre-render when you build your app for production, after you deply taht prerender doesnt change
// if you uddate the data you need to start that build proccess again and re deploy. By default next prepares your pages staticlly in build process
// if you need render fetch data use getStaticProps in page components files, its jobs is to prepare props for the page, next will execute it during the prerendering process
// first next will call getStaticProps before it calls the component function. Next will wait for this promise to resolve until the data is leaded and then return the props,
// then execute the function component and it will render with the required data
export async function getStaticProps() { // gets data fetching for prerendering during the build process
  // this code here will never execute on the client side only in the server side or build process side
  // fetch data from an api or database // read data from a fyle system // the data will be cached by CDN and reused
  // fetchin an internal api is uneccesary request & the code will no expose to the client only in the server side, we can execute the api route code here
  
  const client = await MongoClient.connect(
    'mongodb+srv://janis-jenny:3hV8uSGutv4bIsED@cluster0.4jkrw.mongodb.net/meetups?retryWrites=true&w=majority'
    ); //return promise
  const db = client.db(); //to connect w db
  const meetupsCollections = db.collection('meetups');
  const meetups = await meetupsCollections.find().toArray() // find all documents inside collection

  return {
    props: {
      meetups: meetups.map(meetup => ({
        title: meetup.title,
        address: meetup.address,
        image: meetup.image,
        id: meetup._id.toString()
      }))
    },
    revalidate: 1 //incremental static generation, 
    // it represent the # of seconds that next will wait until regenerate the page for an incoming request on the server
    // depends of the data update frequency, this will occasionally re-pre.-render on the server after deployment, so you dont have to do it manually
  }
}

// if you want to regenerate this page for every request, when the data changes frequently, to pre-generate dynamically the page after deployment on the server
/* export async function getServerSideProps(context) { 
  // this will no run during build process, but on the server side after deployment
  // fetch data from an API // also to perform operations that use credentials that shoudnt be exposed to users
  // gives request and response in the middleware 
  const req = context.req; // helpful for authentication, some session cockie, gives you acces to incoming request and all its headers and the request body 
  // gives you extra data
  const res = context.res;
  return {
    props: {
      meetups: DUMMY_MEETUPS
    }
  }
} */